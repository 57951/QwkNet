using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using QwkNet.Archive;
using QwkNet.Archive.Zip;
using QwkNet.Core;
using QwkNet.Encoding;
using QwkNet.Models.Control;
using QwkNet.Models.Indexing;
using QwkNet.Models.Messages;
using QwkNet.Parsing;

namespace QwkNet;

/// <summary>
/// Represents a REP (reply) packet for upload back to the BBS.
/// </summary>
/// <remarks>
/// <para>
/// REP packets contain user replies to be uploaded to the BBS. The format
/// is similar to QWK packets but contains only messages and their indexes.
/// </para>
/// <para>
/// This class provides deterministic output: given the same messages and
/// control data, the generated bytes will be identical across builds.
/// </para>
/// </remarks>
public sealed class RepPacket : IDisposable
{
  private const int QwkRecordSize = 128;
  private readonly string _bbsId;
  private readonly List<Message> _messages;
  private readonly Dictionary<ushort, List<Message>> _messagesByConference;
  private bool _disposed;

  /// <summary>
  /// Gets the BBS identifier for this REP packet.
  /// </summary>
  /// <remarks>
  /// This is used to name the REP file (e.g., MYBBS.REP) and appears in the
  /// first line of CONTROL.DAT.
  /// </remarks>
  public string BbsId => _bbsId;

  /// <summary>
  /// Gets the read-only collection of messages in this REP packet.
  /// </summary>
  public IReadOnlyList<Message> Messages => _messages;

  /// <summary>
  /// Initialises a new instance of the <see cref="RepPacket"/> class.
  /// </summary>
  /// <param name="bbsId">
  /// The BBS identifier (1-8 characters, typically uppercase).
  /// </param>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="bbsId"/> is <see langword="null"/>.
  /// </exception>
  /// <exception cref="ArgumentException">
  /// Thrown when <paramref name="bbsId"/> is empty, whitespace, or exceeds 8 characters.
  /// </exception>
  private RepPacket(string bbsId)
  {
    if (bbsId == null)
    {
      throw new ArgumentNullException(nameof(bbsId));
    }

    if (string.IsNullOrWhiteSpace(bbsId))
    {
      throw new ArgumentException("BBS ID cannot be empty or whitespace.", nameof(bbsId));
    }

    if (bbsId.Length > 8)
    {
      throw new ArgumentException("BBS ID cannot exceed 8 characters.", nameof(bbsId));
    }

    _bbsId = bbsId;
    _messages = new List<Message>();
    _messagesByConference = new Dictionary<ushort, List<Message>>();
    _disposed = false;
  }

  /// <summary>
  /// Creates a new REP packet using control data from a QWK packet.
  /// </summary>
  /// <param name="control">
  /// The control data from the original QWK packet.
  /// </param>
  /// <returns>
  /// A new <see cref="RepPacket"/> instance ready to receive messages.
  /// </returns>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="control"/> is <see langword="null"/>.
  /// </exception>
  public static RepPacket Create(ControlDat control)
  {
    if (control == null)
    {
      throw new ArgumentNullException(nameof(control));
    }

    return new RepPacket(control.BbsId);
  }

  /// <summary>
  /// Creates a new REP packet with a specific BBS identifier.
  /// </summary>
  /// <param name="bbsId">
  /// The BBS identifier (1-8 characters, typically uppercase).
  /// </param>
  /// <returns>
  /// A new <see cref="RepPacket"/> instance ready to receive messages.
  /// </returns>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="bbsId"/> is <see langword="null"/>.
  /// </exception>
  /// <exception cref="ArgumentException">
  /// Thrown when <paramref name="bbsId"/> is invalid.
  /// </exception>
  public static RepPacket Create(string bbsId)
  {
    return new RepPacket(bbsId);
  }

  /// <summary>
  /// Adds a message to the REP packet.
  /// </summary>
  /// <param name="message">
  /// The message to add.
  /// </param>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="message"/> is <see langword="null"/>.
  /// </exception>
  /// <exception cref="ObjectDisposedException">
  /// Thrown when this instance has been disposed.
  /// </exception>
  /// <remarks>
  /// Messages are added in the order they are provided. The message number
  /// will be recalculated during packet generation to ensure sequential numbering.
  /// </remarks>
  public void AddMessage(Message message)
  {
    ObjectDisposedException.ThrowIf(_disposed, this);

    if (message == null)
    {
      throw new ArgumentNullException(nameof(message));
    }

    _messages.Add(message);

    // Track messages by conference for index generation
    if (!_messagesByConference.ContainsKey(message.ConferenceNumber))
    {
      _messagesByConference[message.ConferenceNumber] = new List<Message>();
    }

    _messagesByConference[message.ConferenceNumber].Add(message);
  }

  /// <summary>
  /// Saves the REP packet to a stream.
  /// </summary>
  /// <param name="output">
  /// The stream to write the REP packet to.
  /// </param>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="output"/> is <see langword="null"/>.
  /// </exception>
  /// <exception cref="ArgumentException">
  /// Thrown when <paramref name="output"/> is not writable.
  /// </exception>
  /// <exception cref="ObjectDisposedException">
  /// Thrown when this instance has been disposed.
  /// </exception>
  /// <remarks>
  /// This method generates a complete REP packet as a ZIP archive containing:
  /// <list type="bullet">
  /// <item><description>CONTROL.DAT - BBS identifier line</description></item>
  /// <item><description>MESSAGES.DAT - All messages with proper padding</description></item>
  /// <item><description>N.NDX files - Index files for each conference</description></item>
  /// </list>
  /// </remarks>
  public void Save(Stream output)
  {
    ObjectDisposedException.ThrowIf(_disposed, this);

    if (output == null)
    {
      throw new ArgumentNullException(nameof(output));
    }

    if (!output.CanWrite)
    {
      throw new ArgumentException("Stream must be writable.", nameof(output));
    }

    using (IArchiveWriter writer = new ZipArchiveWriter())
    {
      // Generate CONTROL.DAT
      using (Stream controlStream = GenerateControlDat())
      {
        writer.AddFile("CONTROL.DAT", controlStream);
      }

      // Generate MESSAGES.DAT
      using (Stream messagesStream = GenerateMessagesDat())
      {
        writer.AddFile("MESSAGES.DAT", messagesStream);
      }

      // Generate index files for each conference
      Dictionary<int, IndexFile> indexes = GenerateIndexes();
      foreach (KeyValuePair<int, IndexFile> kvp in indexes)
      {
        int conferenceNumber = kvp.Key;
        IndexFile indexFile = kvp.Value;

        string indexFileName = $"{conferenceNumber}.NDX";

        using (MemoryStream indexStream = new MemoryStream())
        {
          MessageIndexer.WriteIndex(indexFile, indexStream);
          indexStream.Position = 0;
          writer.AddFile(indexFileName, indexStream);
        }
      }

      // Write the ZIP archive to the output stream
      writer.Save(output);
    }
  }

  /// <summary>
  /// Saves the REP packet to a file.
  /// </summary>
  /// <param name="filePath">
  /// The path to write the REP packet to.
  /// </param>
  /// <exception cref="ArgumentNullException">
  /// Thrown when <paramref name="filePath"/> is <see langword="null"/>.
  /// </exception>
  /// <exception cref="ObjectDisposedException">
  /// Thrown when this instance has been disposed.
  /// </exception>
  public void SaveToFile(string filePath)
  {
    ObjectDisposedException.ThrowIf(_disposed, this);

    if (filePath == null)
    {
      throw new ArgumentNullException(nameof(filePath));
    }

    using (FileStream fs = new FileStream(filePath, FileMode.Create, FileAccess.Write))
    {
      Save(fs);
    }
  }

  /// <summary>
  /// Generates the CONTROL.DAT file content.
  /// </summary>
  /// <returns>
  /// A <see cref="MemoryStream"/> containing the CONTROL.DAT data.
  /// </returns>
  /// <remarks>
  /// For REP packets, CONTROL.DAT typically contains only the BBS ID on the first line.
  /// This is the minimal valid CONTROL.DAT for a reply packet.
  /// </remarks>
  private Stream GenerateControlDat()
  {
    MemoryStream stream = new MemoryStream();
    StreamWriter writer = new StreamWriter(stream, Cp437Encoding.GetEncoding(), leaveOpen: true);

    // REP CONTROL.DAT format: BBS ID on first line
    writer.WriteLine(_bbsId);
    writer.Flush();

    stream.Position = 0;
    return stream;
  }

  /// <summary>
  /// Generates the MESSAGES.DAT file content.
  /// </summary>
  /// <returns>
  /// A <see cref="MemoryStream"/> containing the MESSAGES.DAT data.
  /// </returns>
  /// <remarks>
  /// <para>
  /// MESSAGES.DAT consists of a header record followed by message records.
  /// Each message consists of a 128-byte header followed by N 128-byte blocks
  /// of body text, padded with spaces to fill the last block.
  /// </para>
  /// <para>
  /// The first record (header) contains the BBS ID and copyright notice.
  /// </para>
  /// </remarks>
  private Stream GenerateMessagesDat()
  {
    MemoryStream stream = new MemoryStream();

    // Write MESSAGES.DAT header record
    WriteMessagesHeader(stream);

    // Write each message
    int recordOffset = 1; // Start at record 1 (after header)

    for (int i = 0; i < _messages.Count; i++)
    {
      Message message = _messages[i];

      // Recalculate message number for sequential numbering
      int messageNumber = i + 1;

      // Write message header and body
      recordOffset = WriteMessage(stream, message, messageNumber, recordOffset);
    }

    stream.Position = 0;
    return stream;
  }

  /// <summary>
  /// Writes the MESSAGES.DAT header record.
  /// </summary>
  /// <param name="stream">
  /// The stream to write to.
  /// </param>
  /// <remarks>
  /// The header record is a 128-byte block containing the BBS ID and copyright text.
  /// </remarks>
  private void WriteMessagesHeader(Stream stream)
  {
    byte[] headerRecord = new byte[QwkRecordSize];

    // Fill with spaces
    for (int i = 0; i < headerRecord.Length; i++)
    {
      headerRecord[i] = (byte)' ';
    }

    // Write BBS ID at the start (using CP437 encoding)
    byte[] bbsIdBytes = Cp437Encoding.Encode(_bbsId);
    int copyLength = Math.Min(bbsIdBytes.Length, headerRecord.Length);
    Array.Copy(bbsIdBytes, 0, headerRecord, 0, copyLength);

    // Write the header record
    stream.Write(headerRecord, 0, headerRecord.Length);
  }

  /// <summary>
  /// Writes a single message to MESSAGES.DAT.
  /// </summary>
  /// <param name="stream">
  /// The stream to write to.
  /// </param>
  /// <param name="message">
  /// The message to write.
  /// </param>
  /// <param name="messageNumber">
  /// The sequential message number.
  /// </param>
  /// <param name="recordOffset">
  /// The current record offset in MESSAGES.DAT.
  /// </param>
  /// <returns>
  /// The updated record offset after writing this message.
  /// </returns>
  private int WriteMessage(Stream stream, Message message, int messageNumber, int recordOffset)
  {
    // Build the message header with corrected block count
    byte[] headerBytes = BuildMessageHeader(message, messageNumber);

    // Get the message body text properly encoded for QWK format
    // Use GetEncodedText() which rejoins lines with Ï€ (0xE3) terminators
    string bodyText = message.Body.GetEncodedText();

    // Calculate block count (number of 128-byte blocks needed for the body)
    int bodyBlockCount = CalculateBlockCount(bodyText);

    // Update block count in header (bytes 116-121)
    // Per QWK specification: this field is "number of 128 byte blocks INCLUDING
    // 1 for the message header" - so we write bodyBlockCount + 1
    int totalBlockCount = bodyBlockCount + 1;
    WriteBlockCount(headerBytes, totalBlockCount);

    // Write message header
    stream.Write(headerBytes, 0, headerBytes.Length);
    recordOffset++;

    // Write message body blocks
    WriteMessageBody(stream, bodyText, bodyBlockCount);
    recordOffset += bodyBlockCount;

    return recordOffset;
  }

  /// <summary>
  /// Builds a message header byte array.
  /// </summary>
  /// <param name="message">
  /// The message to build a header for.
  /// </param>
  /// <param name="messageNumber">
  /// The sequential message number.
  /// </param>
  /// <returns>
  /// A 128-byte array containing the message header.
  /// </returns>
  private static byte[] BuildMessageHeader(Message message, int messageNumber)
  {
    byte[] headerBytes = new byte[QwkRecordSize];

    // Copy the raw header bytes directly
    byte[] rawHeaderBytes = message.RawHeader.RawHeader;
    Array.Copy(rawHeaderBytes, 0, headerBytes, 0, QwkRecordSize);

    // Clear the message number field (bytes 1-7) with spaces
    for (int i = 1; i < 8; i++)
    {
      headerBytes[i] = (byte)' ';
    }

    // Update message number (bytes 1-7)
    WriteAsciiField(headerBytes, 1, messageNumber.ToString(), 7);

    return headerBytes;
  }

  /// <summary>
  /// Converts <see cref="MessageStatus"/> flags to a QWK status byte.
  /// </summary>
  /// <param name="status">
  /// The status flags.
  /// </param>
  /// <returns>
  /// The QWK status byte.
  /// </returns>
  private static byte ConvertStatusToQwkByte(MessageStatus status)
  {
    bool isPrivate = status.HasFlag(MessageStatus.Private);
    bool isRead = status.HasFlag(MessageStatus.Read);
    bool isCommentToSysop = status.HasFlag(MessageStatus.CommentToSysop);
    bool isSenderPassword = status.HasFlag(MessageStatus.SenderPasswordProtected);
    bool isGroupPassword = status.HasFlag(MessageStatus.GroupPasswordProtected);
    bool isGroupPasswordToAll = status.HasFlag(MessageStatus.GroupPasswordProtectedToAll);

    // Handle password protection first (highest priority)
    if (isGroupPasswordToAll)
    {
      return (byte)'$';
    }

    if (isGroupPassword)
    {
      return (byte)(isRead ? '#' : '!');
    }

    if (isSenderPassword)
    {
      return (byte)(isRead ? '^' : '%');
    }

    if (isCommentToSysop)
    {
      return (byte)(isRead ? '`' : '~');
    }

    if (isPrivate)
    {
      return (byte)(isRead ? '+' : '*');
    }

    // Public message
    return (byte)(isRead ? '-' : ' ');
  }

  /// <summary>
  /// Writes an ASCII field to the header byte array.
  /// </summary>
  /// <param name="headerBytes">
  /// The header byte array.
  /// </param>
  /// <param name="offset">
  /// The starting offset (0-based).
  /// </param>
  /// <param name="value">
  /// The value to write.
  /// </param>
  /// <param name="maxLength">
  /// The maximum field length.
  /// </param>
  private static void WriteAsciiField(byte[] headerBytes, int offset, string value, int maxLength)
  {
    if (string.IsNullOrEmpty(value))
    {
      return;
    }

    // Truncate if necessary
    string truncated = value.Length > maxLength ? value.Substring(0, maxLength) : value;

    // Write bytes using CP437 encoding
    byte[] valueBytes = Cp437Encoding.Encode(truncated);
    Array.Copy(valueBytes, 0, headerBytes, offset, valueBytes.Length);
  }

  /// <summary>
  /// Calculates the number of 128-byte blocks needed for a message body.
  /// </summary>
  /// <param name="bodyText">
  /// The message body text.
  /// </param>
  /// <returns>
  /// The number of blocks needed.
  /// </returns>
  private static int CalculateBlockCount(string bodyText)
  {
    if (string.IsNullOrEmpty(bodyText))
    {
      return 1; // Minimum 1 block
    }

    // Use CP437 encoding to calculate byte count
    byte[] encoded = Cp437Encoding.Encode(bodyText);
    int byteCount = encoded.Length;
    int blockCount = (byteCount + QwkRecordSize - 1) / QwkRecordSize;

    return Math.Max(1, blockCount);
  }

  /// <summary>
  /// Writes the block count to the message header.
  /// </summary>
  /// <param name="headerBytes">
  /// The header byte array.
  /// </param>
  /// <param name="blockCount">
  /// The block count to write.
  /// </param>
  private static void WriteBlockCount(byte[] headerBytes, int blockCount)
  {
    // Block count is at bytes 116-121 (6 bytes, ASCII)
    string blockCountStr = blockCount.ToString().PadLeft(6);
    WriteAsciiField(headerBytes, 116, blockCountStr, 6);
  }

  /// <summary>
  /// Writes the message body to the stream.
  /// </summary>
  /// <param name="stream">
  /// The stream to write to.
  /// </param>
  /// <param name="bodyText">
  /// The message body text.
  /// </param>
  /// <param name="blockCount">
  /// The number of blocks to write.
  /// </param>
  private static void WriteMessageBody(Stream stream, string bodyText, int blockCount)
  {
    // Use CP437 encoding for body text
    byte[] bodyBytes = Cp437Encoding.Encode(bodyText ?? string.Empty);
    int totalSize = blockCount * QwkRecordSize;

    // Create padded buffer
    byte[] paddedBuffer = new byte[totalSize];

    // Fill with spaces
    for (int i = 0; i < paddedBuffer.Length; i++)
    {
      paddedBuffer[i] = (byte)' ';
    }

    // Copy body bytes
    int copyLength = Math.Min(bodyBytes.Length, paddedBuffer.Length);
    Array.Copy(bodyBytes, 0, paddedBuffer, 0, copyLength);

    // Write to stream
    stream.Write(paddedBuffer, 0, paddedBuffer.Length);
  }

  /// <summary>
  /// Generates index files for all conferences in this REP packet.
  /// </summary>
  /// <returns>
  /// A dictionary mapping conference numbers to their index files.
  /// </returns>
  private Dictionary<int, IndexFile> GenerateIndexes()
  {
    Dictionary<int, IndexFile> indexes = new Dictionary<int, IndexFile>();
    Dictionary<int, List<IndexEntry>> entriesByConference = new Dictionary<int, List<IndexEntry>>();

    // Build indexes by conference
    int globalRecordOffset = 1; // Start at record 1 (after MESSAGES.DAT header)

    foreach (Message message in _messages)
    {
      int conferenceNumber = message.ConferenceNumber;

      // Initialise conference tracking if needed
      if (!entriesByConference.ContainsKey(conferenceNumber))
      {
        entriesByConference[conferenceNumber] = new List<IndexEntry>();
      }

      // Calculate block count for this message body
      // Use GetEncodedText() for consistency with WriteMessage
      int bodyBlockCount = CalculateBlockCount(message.Body.GetEncodedText());

      // Get the entry list for this conference
      List<IndexEntry> entries = entriesByConference[conferenceNumber];

      // Create index entry
      int messageNumber = entries.Count + 1;
      byte[] msbinBytes = MsbinConverter.FromDouble((double)globalRecordOffset);
      IndexEntry entry = new IndexEntry(messageNumber, globalRecordOffset, msbinBytes);

      entries.Add(entry);

      // Advance record offset (1 header + N body blocks)
      globalRecordOffset += (1 + bodyBlockCount);
    }

    // Convert lists to IndexFile instances
    foreach (KeyValuePair<int, List<IndexEntry>> kvp in entriesByConference)
    {
      int conferenceNumber = kvp.Key;
      List<IndexEntry> entries = kvp.Value;

      IndexFile indexFile = new IndexFile(
        conferenceNumber,
        entries,
        isValid: true,
        validatedAgainstFileSize: 0);

      indexes[conferenceNumber] = indexFile;
    }

    return indexes;
  }

  /// <summary>
  /// Releases the resources used by this <see cref="RepPacket"/>.
  /// </summary>
  public void Dispose()
  {
    if (_disposed)
    {
      return;
    }

    _messages.Clear();
    _messagesByConference.Clear();
    _disposed = true;
  }
}